# answer rule only

BEGIN_PGML
[_]
END_PGML

==>

Program(PGMLBlock(BeginPG, PGMLContent(Paragraph(AnswerRule)), EndPG))

==>

from: '0'
parseAll: 'true'
to: '3'
type: 'root'
stack: [
  [ # 0
    combine: { indent: 'indent', list: { indent: '1' }, par: 'true' }
    from: '0'
    indent: '0'
    to: '3'
    type: 'indent'
    stack: [
      [ # 0
        from: '0'
        options: ['answer', 'width', 'name', 'cmp_options']
        to: '3'
        token: '[_]'
        type: 'answer'
      ]
    ]
  ]
]

# answer rule with answer and width options

BEGIN_PGML
[_]{$a}{15}
END_PGML

==>

Program(
    PGMLBlock(
        BeginPG,
        PGMLContent(
            Paragraph(
                AnswerRule,
                Option(OptionMark, Program(ExpressionStatement(ScalarVariable)), OptionMark),
                Option(OptionMark, Program(ExpressionStatement(Integer)), OptionMark)
            )
        ),
        EndPG
    )
)

==>

from: '0'
parseAll: 'true'
to: '11'
type: 'root'
stack: [
  [ # 0
    combine: { indent: 'indent', list: { indent: '1' }, par: 'true' }
    from: '0'
    indent: '0'
    to: '11'
    type: 'indent'
    stack: [
      [ # 0
        from: '0'
        optionStack: [
          {
            from: '3'
            terminator: '}'
            text: '$a'
            to: '7'
            token: '{'
            type: 'options'
          },
          {
            from: '7'
            terminator: '}'
            text: '15'
            to: '11'
            token: '{'
            type: 'options'
          }
        ]
        options: ['answer', 'width', 'name', 'cmp_options']
        to: '11'
        token: '[_]'
        type: 'answer'
      ]
    ]
  ]
]

# array answer rule with answer and width options

BEGIN_PGML
[_]*{$matrix}{10}
END_PGML

==>

Program(
    PGMLBlock(
        BeginPG,
        PGMLContent(
            Paragraph(
                AnswerRule,
                Option(OptionMark, Program(ExpressionStatement(ScalarVariable)), OptionMark),
                Option(OptionMark, Program(ExpressionStatement(Integer)), OptionMark)
            )
        ),
        EndPG
    )
)

==>

from: '0'
parseAll: 'true'
to: '17'
type: 'root'
stack: [
  [ # 0
    combine: { indent: 'indent', list: { indent: '1' }, par: 'true' }
    from: '0'
    indent: '0'
    to: '17'
    type: 'indent'
    stack: [
      [ # 0
        from: '0'
        hasStar: '1'
        optionStack: [
          {
            from: '4'
            terminator: '}'
            text: '$matrix'
            to: '13'
            token: '{'
            type: 'options'
          },
          {
            from: '13'
            terminator: '}'
            text: '10'
            to: '17'
            token: '{'
            type: 'options'
          }
        ]
        options: ['answer', 'width', 'name', 'cmp_options']
        to: '17'
        token: '[_]*'
        type: 'answer'
      ]
    ]
  ]
]

# answer rule with key-value options format

BEGIN_PGML
[_]{ answer => $pi, name => NEW_ANS_NAME(), width => 10, cmp_options => { tolerance => 0.00001 } }
END_PGML

==>

Program(
    PGMLBlock(
        BeginPG,
        PGMLContent(
            Paragraph(
                AnswerRule,
                Option(
                    OptionMark,
                    Program(
                        ExpressionStatement(
                            Pair(Identifier, FatComma, ScalarVariable),
                            Comma,
                            Pair(
                                Identifier,
                                FatComma,
                                CallExpression(FunctionName(Identifier), ParenthesizedArguments("(", ")"))
                            ),
                            Comma,
                            Pair(Identifier, FatComma, Integer),
                            Comma,
                            Pair(Identifier, FatComma, HashRef("{", Pair(Identifier, FatComma, Float), "}"))
                        )
                    ),
                    OptionMark
                )
            )
        ),
        EndPG
    )
)

==>

from: '0'
parseAll: 'true'
to: '98'
type: 'root'
stack: [
  [ # 0
    combine: { indent: 'indent', list: { indent: '1' }, par: 'true' }
    from: '0'
    indent: '0'
    to: '98'
    type: 'indent'
    stack: [
      [ # 0
        from: '0'
        optionStack: [
          {
            from: '3'
            terminator: '}'
            text: ' answer => $pi, name => NEW_ANS_NAME(), width => 10, cmp_options => { tolerance => 0.00001 } '
            to: '98'
            token: '{'
            type: 'options'
          }
        ]
        options: ['answer', 'width', 'name', 'cmp_options']
        to: '98'
        token: '[_]'
        type: 'answer'
      ]
    ]
  ]
]

# answer rule with answer and width options and cmp_options provided as a last key-value option

BEGIN_PGML
[_]{$pi}{10}{ cmp_options => { tolerance => 0.00001 } }
END_PGML

==>

Program(
    PGMLBlock(
        BeginPG,
        PGMLContent(
            Paragraph(
                AnswerRule,
                Option(OptionMark, Program(ExpressionStatement(ScalarVariable)), OptionMark),
                Option(OptionMark, Program(ExpressionStatement(Integer)), OptionMark),
                Option(
                    OptionMark,
                    Program(
                        ExpressionStatement(
                            Pair(Identifier, FatComma, HashRef("{", Pair(Identifier, FatComma, Float), "}"))
                        )
                    ),
                    OptionMark
                )
            )
        ),
        EndPG
    )
)

==>

from: '0'
parseAll: 'true'
to: '55'
type: 'root'
stack: [
  [ # 0
    combine: { indent: 'indent', list: { indent: '1' }, par: 'true' }
    from: '0'
    indent: '0'
    to: '55'
    type: 'indent'
    stack: [
      [ # 0
        from: '0'
        optionStack: [
          {
            from: '3'
            terminator: '}'
            text: '$pi'
            to: '8'
            token: '{'
            type: 'options'
          },
          {
            from: '8'
            terminator: '}'
            text: '10'
            to: '12'
            token: '{'
            type: 'options'
          },
          {
            from: '12'
            terminator: '}'
            text: ' cmp_options => { tolerance => 0.00001 } '
            to: '55'
            token: '{'
            type: 'options'
          }
        ]
        options: ['answer', 'width', 'name', 'cmp_options']
        to: '55'
        token: '[_]'
        type: 'answer'
      ]
    ]
  ]
]
